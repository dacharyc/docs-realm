.. _synced-schema-overview:

==================
Update Your Schema
==================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

When developing an application using {+sync+}, you may need to make changes to
your schema at some point, such as when you: 

- Need to add a new property to an already-synced object
- Decide to change the type stored in a property
- Have to change an optional property to *required* 

To make it easier to understand how schema changes affect your app, we
characterize them as "breaking" versus "non-breaking" changes.

The {+service-short+} APIs provide for non-breaking schema changes to synced 
realms, allowing old clients to sync with newer ones.

Breaking schema changes, however, take some planning and work, and should
be avoided whenever possible.

Breaking schema changes are difficult because older clients (those that 
have not been updated to your new code and schema) still need access to 
the data via the old schema definition. Clients that are updated need to 
work with the new schema changes.

.. important:: Breaking and Non-Breaking may differ between server and client

   Some things that are non-breaking as server-side schema changes become
   breaking changes in the client object model, and vice versa. Do not
   consider the client model and the server schema interchangeable.

.. _additive-changes-synced-schema:
.. _non-breaking-changes-synced-schema:

Non-Breaking Changes
--------------------

A non-breaking change is a change that you can make in your server-side
schema or your object model without requiring additional handling in your
app.

Server-Side Schema Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~

Non-breaking changes to the server-side schema are **additions** to the 
schema, such as:

- adding a class
- adding a required property to an existing class
- adding an optional property to an existing class

Realm refers to these types of non-breaking changes as additive changes.
They apply automatically to synced {+realms+}; you can make these 
non-breaking schema changes with no additional client-side configuration 
changes.

.. note:: Applying non-breaking changes to the client may require migration

   When you _only_ make non-breaking changes to the server-side schema, 
   no additional action is required. However, if you then try to apply 
   these changes to your client object model, you may need to perform 
   a migration. If the client device has an existing realm file, you must
   perform a migration. For details, see the Modify an Object Schema
   page in your preferred SDK.

Client Object Model Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~

One type of change is non-breaking when you make it in the client object 
model, but breaking when you make it in the server side schema: removing 
a property from an object.

To maintain backward compatibility, removing a property from a client-side 
object model does not delete the property from the database. Instead, 
new objects retain the removed property, but Realm automatically sets the 
property's value to ``null``. Realm sets properties that are non-nullable to an
appropriate empty value, such as a 0 for integer values or an empty string
for string values. This is considered a non-breaking or additive change
to the object model.

However, if you remove a property from your object model and _also_ try to 
remove it from your server-side schema, removing it from the server-side
schema _is_ a breaking change. So you can safely remove a property from the 
client-side object model as a non-breaking change, but trying to remove it 
from the server-side schema is a breaking change.

To avoid making a breaking change to the server-side schema, leave existing
fields in place even if you remove them from the client-side object model.
Then this operation is a non-breaking change.

.. _destructive-changes-synced-schema:
.. _breaking-changes-synced-schema:

Breaking Changes
----------------

A breaking change is a change that you can make in your server-side
schema that requires additional action to handle. Failing to handle these 
changes properly can result in clients being unable to open a realm, or
the appearance of data loss when server-side documents are unable to 
sync to client-side applications.

One example of a breaking change is a destructive change that requires you 
to :ref:`terminate and re-enable Sync <terminating-realm-sync>`, and 
perform a :ref:`client reset <client-resets>`. However, there
are also changes that may prevent documents from syncing to the device,
giving the appearance of lost data. Both of these types of changes are 
breaking changes.

**Modifications** of existing properties are breaking changes, whether you
modify the server-side schema or the client object model:

- changing a property's type but keeping the same name
- changing a property's name
- changing a primary key
- changing a property from optional to required (or vice-versa)

Server-Side Schema Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~

In addition to the modifications above, some changes are breaking changes 
when you perform them on the server-side schema, but are non-breaking when you 
perform them only on the object model. These changes include:

- removing a required property from a class
- removing an optional property from a class
- removing a class

Client Object Model Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Synchronized {+realms+} only support non-breaking changes to a client object 
model. Attempting to perform a breaking change to a client object model on a 
synchronized {+realm+} leads to errors like the following:

.. code-block:: shell

   {
    message: 'The following changes cannot be made in additive-only schema mode:\n' +
      "- Property 'Task._id' has been changed from 'int' to 'string'.",
    errorCode: 1
   }

.. _partner_collections:
.. _handle-breaking-sync-schema-changes:

How to Handle Breaking Changes
------------------------------

If you are developing an application using Realm Sync and need to make a 
breaking schema change, you have two choices: 

- :ref:`Terminate sync <terminating-realm-sync>` in the backend and then
  :ref:`re-enable <enable-sync>` sync, which triggers a :ref:`client reset <client-resets>`
- Create a **"partner collection"**

When you terminate and re-enable Sync and perform a client reset, you must
handle any unsynced changes on client devices. You can discard the changes,
or write your own logic to attempt to sync them. Terminating and re-enabling
Sync is extremely disruptive to production applications, so it is not
recommended except as a last resort. 

If you must make breaking changes to your schema, the preferred technique 
is to let the existing collection remain in place with the existing schema, 
and create a partner collection with the new schema. 

A partner collection is a collection that contains the same data as
the original collection, but has the new schema definition in place. Partner
collections use database triggers to ensure that data flows in both directions,
meaning that when one collection is written to, the other is also written to 
(with the data modifications required for the new schema).

To implement a breaking schema change, see :ref:`<migrate-schema-partner-collection>`.

.. note:: Make destructive changes via the Realm UI

   Because destructive schema changes require special handling, Realm does not
   support making these changes via Realm CLI or automated deploy with GitHub.
   Instead, you should make destructive changes in the Realm UI.

Some Breaking Changes Require Additional Handling in Atlas
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With some types of breaking changes, even after you terminate and re-enable 
Sync and perform a client reset, you must do perform additional handling
of existing Atlas documents to enable them to Sync with your client 
applications. Without this additional handling, those documents do not Sync
and it may appear in the client that the data has been lost.

These breaking changes require additional handling of existing Atlas documents:

- Changing a property's type but keeping the same name
- Changing a property's name

For these changes, if an Atlas document maintains the old property type or 
property name, the document no longer syncs to the client application. You 
could resolve this issue in a few ways:

- Change the old field name or field type on each document to match the new schema
- Add a new field to each document that matches the new schema, and copy the 
  value from the old field into it, transforming its type if necessary

After you've made these changes, the appropriate documents should once again 
sync to the client application.

Summary
-------

- Schema changes on synced {+realms+} are backward compatible, allowing old clients to sync with newer ones.
- Non-breaking changes to the schema of a synced {+realm+} do not require any additional configuration. 
- Synchronized {+realms+} only support non-breaking changes to a schema.
- Breaking changes are modifications to existing properties of a schema.
- Synchronized {+realms+} do not support breaking changes directly. 
- To perform breaking schema changes to a synced {+realm+}, create a partner collection with the necessary schema changes and manually copy the data from the first collection to the second collection.
- To keep partner collections up-to-date with each other, set up database triggers to copy changed data from one collection to its partner.
